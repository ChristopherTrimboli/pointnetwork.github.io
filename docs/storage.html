<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Storage · Point Network</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# Point Network Storage Layer"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Storage · Point Network"/><meta property="og:type" content="website"/><meta property="og:url" content="https://pointnetwork.github.io/"/><meta property="og:description" content="# Point Network Storage Layer"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.9.0/mermaid.min.js"></script><script type="text/javascript" src="/init.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="Point Network"/><h2 class="headerTitleWithLogo">Point Network</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/welcome" target="_self">Getting Started</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Introduction</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/welcome">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/modules">Modules</a></li><li class="navListItem"><a class="navItem" href="/docs/deploy">Deploy</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/storage">Storage</a></li><li class="navListItem"><a class="navItem" href="/docs/token">Token</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Storage</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="point-network-storage-layer"></a><a href="#point-network-storage-layer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Point Network Storage Layer</h1>
<p>To save a file in the storage layer, a developer can call the putFile function passing in the file like so: <code>storage.putFile(filePath)</code>. This is a function call that will return the unique file id of the file originally located at the <code>filePath</code>.</p>
<p>Firstly we can outline this using high level state machine diagrams for <code>File</code>, <code>Chunk</code> and <code>ProviderLink</code> as follows.</p>
<h2><a class="anchor" aria-hidden="true" id="file-states"></a><a href="#file-states" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>File States</h2>
<div class="mermaid">stateDiagram-v2
  [*] --> Created: putFile
  Created --> Uploading: chunkify
  Uploading --> Uploaded: chunks_uploading==0
  Uploading --> Uploading: chunks_uploading>0
  Uploaded --> [*]
</div><h2><a class="anchor" aria-hidden="true" id="chunk-states"></a><a href="#chunk-states" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Chunk States</h2>
<div class="mermaid">stateDiagram-v2
  [*] --> Created: createChunkFromFile
  Created --> Uploading: check state
  Uploading --> Uploading: chunk conditions \nNOT satisfied
  Uploading --> Uploaded: chunk conditions satisfied
  Uploaded --> [*]
</div><h2><a class="anchor" aria-hidden="true" id="storage-link-states"></a><a href="#storage-link-states" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Storage Link States</h2>
<p>NOTE: Yellow boxes represent communication to the linked node.</p>
<div class="mermaid">stateDiagram-v2
  [*] --> Created
  Created --> Agreed
  Created --> Failed
  note left of Created: STORE_CHUNK_REQUEST
  Agreed --> Establish_payment_channel:Payment channel does not exists
  Agreed --> Encrypting:Payment channel already exists
  Establish_payment_channel --> Encrypting
  Encrypting --> Encrypted
  Encrypting --> Failed
  Encrypted --> SendingSegmentMap
  note left of SendingSegmentMap: STORE_CHUNK_SEGMENTS
  SendingSegmentMap --> SendingData
  note left of SendingData: STORE_CHUNK_DATA
  SendingSegmentMap --> Failed
  SendingData --> DataReceived
  SendingData --> Failed
  DataReceived --> AskingForSignature
  AskingForSignature --> Signed
  AskingForSignature --> Failed
  note left of AskingForSignature: STORE_CHUNK_SIGNATURE_REQUEST
  Failed --> [*]
  Signed --> [*]
  note left of Signed: SEND_MICROPAYMENT_FOR_CHUNK
</div><h2><a class="anchor" aria-hidden="true" id="process-upload-and-chunkify-file"></a><a href="#process-upload-and-chunkify-file" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Process: upload and chunkify file</h2>
<ol>
<li><p><code>Storage.putFile</code> - the public storage interface for storing a file on the network. It calls <code>Storage.enqueueFileForUpload</code> and waits to get the file id of the file (file may not be uploaded yet). Then waits until the File uploading status is <code>File.UPLOADING_STATUS_UPLOADED</code>. It also calls <code>Storage.chunkUploadingTick</code> to ensure the chunks are uploaded based on the expectations set in the file metadata.</p></li>
<li><p><code>Storage.enqueueFileForUpload</code>- This calls <code>File.chunkify</code> (see details below) and sets the files metadata for redundancy, expiry and auto renew policies. Once the file is broken into chunks it calls <code>File.reconsiderUploadingStatus</code> (see below).</p></li>
<li><p><code>File.chunkify</code> - splits the file by breaking the file into chunks of equal size of bytes upto the last chunk which may be smaller in size. It also creates a merkle tree using the chunk ids as the leaves. Each chunk has an initial state of <code>Chunk.UPLOADING_STATUS_CREATED</code>.</p></li>
<li><p><code>File.reconsiderUploadingStatus</code> - sets the chunks metadata for <strong>redundancy</strong>, <strong>expiry</strong> and <strong>auto renew</strong> policies and then calls <code>Chunk.reconsiderUploadingStatus</code> for each chunk (see below).</p></li>
<li><p><code>Chunk.reconsiderUploadingStatus</code> - checks that the chunk has the expected data redundancy (i.e. that it is stored in at least N providers) and that it has not expired. If any of these are not settled then the status of the chunk is set to Chunk.<code>UPLOADING_STATUS_UPLOADING</code> otherwise it is considered uploaded and so the status is set to <code>Chunk.UPLOADING_STATUS_UPLOADED</code></p></li>
<li><p><code>Storage.chunkUploadingTick</code> - this function is called as a result of the original call to <code>Storage.putFile</code> and it is also called on every ‘tick’ if there are any chunks that have a status Chunk.<code>UPLOADING_STATUS_UPLOADING</code>. In this function the chunks Storage Links  are pushed through various states of the uploading process and we can run though these states in the next step.</p></li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="process-checking-upload-status"></a><a href="#process-checking-upload-status" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Process: checking upload status</h2>
<p>The <code>Storage.chunkUploadingTick</code> function checks, and potentially, modifies the state of all the Storage Links of an uploading file chunk. The state of the chunk must be in <code>Chunk.UPLOADING_STATUS_UPLOADING</code> for this function to proceed.</p>
<p>The function proceeds as follows:</p>
<ol>
<li><p>Checks if the uploading chunk is required to be pushed to additional storage providers. It does this by fetching all the Storage Links for the chunk that have not failed and then compares that with the chunk redundancy to determine if more are required.</p></li>
<li><p><code>StorageLink.STATUS_CREATED</code>: If additional Storage Providers are required then one is chosen using <code>chooseProviderCandidate()</code> function. The process of choosing a provider candidate is detailed elsewhere in the docs. A new Storage Link is created and the provider, <strong>redkeyId</strong>, and <strong>chunk id</strong> is set on this new instance.</p></li>
<li><p><code>StorageLink.STATUS_AGREED</code>: A <code>STORE_CHUNK_REQUEST</code> call is made to the linked Storage Provider and if agreed a check to determine if there is an existing payment channel between the client and the storage provider is carried out using <code>checkExistingChannel()</code> function. If a channel exists the status is updated to <code>StorageLink.STATUS_AGREED</code> otherwise it is updated to <code>StorageLink.STATUS_ESTABLISH_PAYMENT_CHANNEL</code> if the <code>STORE_CHUNK_REQUEST</code> call fails it is updated to <code>StorageLink.STATUS_FAILED</code>. The <code>STORE_CHUNK_REQUEST</code> call is handled using a custom Kademlia plugin or middleware that defines this handler (more on networking in a separate section of the documentation). Note this is a request to another node to store the chunk and at this point the actual chunk data is not sent to the other node - only the id, length and expiry parameters are sent.</p></li>
<li><p><code>StorageLink.STATUS_ESTABLISH_PAYMENT_CHANNEL</code>: The function then checks in the  <code>StorageLink.STATUS_ESTABLISH_PAYMENT_CHANNEL</code> state and creates a payment channel with the Storage Provider using <code>createChannel()</code> function. if successful the status is updated to <code>StorageLink.STATUS_AGREED</code>.</p></li>
<li><p><code>StorageLink.STATUS_ENCRYPTING</code>: The function then checks all the Storage Links in the <code>StorageLink.STATUS_AGREED</code> state and begins the encryption process. The Storage Link state is first updated to <code>StorageLink.STATUS_ENCRYPTING</code>  and then the encryption process is performed by a forked child process that returns a message to the parent process when the encryption is complete.</p></li>
<li><p><code>StorageLink.STATUS_ENCRYPTED</code>: The resulting encrypted chunk is split into multiple segment hashes used to produce a Merkle Tree representation of the chunk. This is then used to update the Storage Link once more with the resulting encrypted hash, encryption data length, segment hashes, merkle tree and merkle tree root. The status is updated to <code>StorageLink.STATUS_ENCRYPTED</code> at this point or <code>StorageLink.STATUS_FAILED</code> if the encryption process failed.</p></li>
<li><p>StorageLink.STATUS_SENDING_SEGMENT_MAP: The function then checks all the Storage Links in the <code>StorageLink.STATUS_ENCRYPTED</code> state and begins sending the segment map to the linked Storage Provider. It first sets the state to <code>StorageLink.STATUS_SENDING_SEGMENT_MAP</code> and then calls <code>STORE_CHUNK_SEGMENTS</code> on the linked Storage Provider. The status is then updated to either <code>StorageLink.STATUS_SENDING_DATA</code> if the request was successful or <code>StorageLink.STATUS_DATA_RECEIVED</code> if the response was ECHUNKALREADYSTORED from the linked Storage Provider. As always, if there was an error then the status is set to <code>StorageLink.STATUS_FAILED</code> .</p></li>
<li><p><code>StorageLink.STATUS_SENDING_DATA</code>: The function then checks all the Storage Links in the <code>StorageLink.STATUS_SENDING_DATA</code> state and then prepares the data to be sent to the linked Storage Provider (which includes checking if chunks should be retransmitted due to a timeout condition). Once the data is prepared it calls <code>STORE_CHUNK_DATA</code>  which will invoke the equivalent function on the linked Storage Provider instance which will then store the data sent. On successful transmission of the data the Storage Link status is updated to <code>StorageLink.STATUS_DATA_RECEIVED</code> otherwise it is updated to <code>StorageLink.STATUS_FAILED</code>.</p></li>
<li><p><code>StorageLink.STATUS_DATA_RECEIVED</code>: The function then checks all the Storage Links in the <code>StorageLink.STATUS_DATA_RECEIVED</code> state and updates the state to <code>StorageLink.STATUS_ASKING_FOR_SIGNATURE</code> and then sends a request to the linked Storage Provider for it to sign the chunk. Once it is successfully signed the status is changed to <code>StorageLink.STATUS_SIGNED</code> and the agreed micropayment is made to the Storage Provider using the makePayment() function. otherwise it is updated to <code>StorageLink.STATUS_FAILED</code>.</p></li>
</ol>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/deploy"><span class="arrow-prev">← </span><span>Deploy</span></a><a class="docs-next button" href="/docs/token"><span>Token</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#file-states">File States</a></li><li><a href="#chunk-states">Chunk States</a></li><li><a href="#storage-link-states">Storage Link States</a></li><li><a href="#process-upload-and-chunkify-file">Process: upload and chunkify file</a></li><li><a href="#process-checking-upload-status">Process: checking upload status</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/favicon.ico" alt="Point Network" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/welcome.html">Getting Started</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="https://github.com/pointnetwork">GitHub</a><a class="github-button" href="https://github.com/pointnetwork" data-icon="octicon-star" data-count-href="/pointnetwork/pointnetwork/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2021 Point Network Limited</section></footer></div></body></html>